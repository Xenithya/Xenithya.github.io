[{"content":"DSP裸机NBG U8类型运行错误 - 深度技术分析与解决方案 一、问题概述 症状 错误日志：[0x0]gcpnna_patch_network_outputs[409], output logical in cmd is NULL, output 1, slice=0 数据类型依赖：仅在U8类型NBG出现，INT16类型正常 平台依赖：仅在DSP裸机出现，RT-Thread操作系统下正常 关键观察 同一代码库，不同数据类型表现不同 同一平台，有/无操作系统表现不同 用户的修复（添加Canary保护）有效解决问题 二、根本原因分析 2.1 结构体定义回顾 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct _pnna_io_patch_info { pnna_uint32_t slice_num; // 切片数量 pnna_address_t *logical_in_cmd; // 逻辑地址指针数组 pnna_uint32_t *physical_in_cmd; // 物理地址指针数组 pnna_uint32_t *offsets; // 偏移数组 pnna_uint32_t *transformation; // 变换数组 pnna_uint32_t counter; pnna_uint32_t physical; pnna_uint8_t *logical; pnna_uint8_t **sw_op_buffer; // 软件操作缓冲 pnna_buffer buffer; pnna_uint32_t patch_belong; } gcpnna_io_patch_info_t; 2.2 原有分配代码的问题 位置：gcpnna_create_io_patch_info() 函数 (第1399-1411行)\n1 2 3 4 // 原代码 pnna_uint32_t tmp_size = sizeof(pnna_address_t) * io_info-\u0026gt;slice_num; gcOnError(gcpnna_user_allocate_memory(tmp_size, (void **)\u0026amp;io_info-\u0026gt;logical_in_cmd)); gcpnna_user_zero_memory(io_info-\u0026gt;logical_in_cmd, tmp_size); 问题根源：\n问题1：缺少对齐保护机制 原分配大小：sizeof(pnna_address_t) * slice_num 字节 缺陷： 假设 pnna_address_t = 8字节（64位） 假设 slice_num = 1 分配大小 = 8字节 这是一个最小单位的精确分配 问题2：内存踩踏(Buffer Overflow) 后续代码写入 physical_in_cmd, offsets, transformation 等 这些是独立分配的内存 但在某些条件下（如内存不连续或分配器特性）可能发生越界 问题3：C66X DSP硬件对齐要求 C66X DSP：固定点数字信号处理器 典型对齐要求： 普通数据：4字节或8字节对齐 向量操作：16字节或32字节对齐 缓冲指针：可能需要特殊对齐 问题4：数据类型特异性 INT16数据：\n较大的数据块 处理量较少 内存压力小 对齐要求相对宽松 U8数据：\n较小的数据块 需要处理更多元素 内存访问密集 可能触发硬件对齐检查 2.3 裸机 vs 操作系统的差异 RT-Thread（正常工作） 1 2 3 4 5 6 7 8 9 10 应用层 ↓ RT-Thread 内存管理层 ├─ 内存对齐检查 ├─ 内存保护机制 ├─ Cache一致性管理 ├─ MMU虚拟地址映射 └─ 内存屏障(barriers) ↓ 底层硬件 RT-Thread的保护作用：\n系统调用的内存分配器可能有额外的对齐逻辑 可能自动添加了保护页面 MMU可能提供了额外的访问检查 内存屏障确保访问顺序 裸机（出现错误） 1 2 3 4 5 6 7 8 9 10 应用层 ↓ 直接硬件内存操作 └─ 无对齐检查 └─ 无保护机制 └─ 无Cache一致性 └─ 直接物理地址 └─ 无访问限制 ↓ 底层硬件 裸机的风险：\n任何内存错误都直接影响程序 无额外的保护机制 需要驱动代码完全负责对齐和保护 三、用户修复方案的工作原理 3.1 修复代码 1 2 3 4 5 6 7 8 9 10 11 // 修复：添加Canary保护 pnna_uint32_t payload_size = sizeof(pnna_address_t) * io_info-\u0026gt;slice_num; const pnna_uint32_t canary_bytes = sizeof(pnna_uint64_t); // 8字节 pnna_uint32_t alloc_size = payload_size + 2 * canary_bytes; // +16字节总 void *alloc_base = PNNA_NULL; gcOnError(gcpnna_user_allocate_memory(alloc_size, (void **)\u0026amp;alloc_base)); /* 有效载荷位于前缀Canary之后 */ io_info-\u0026gt;logical_in_cmd = (pnna_address_t *)((pnna_uint8_t *)alloc_base + canary_bytes); gcpnna_user_zero_memory(io_info-\u0026gt;logical_in_cmd, payload_size); 3.2 为什么有效 机制1：内存对齐改善 1 2 3 4 5 6 7 8 9 10 11 12 原分配（8字节）： ┌──────────────────────────────────┐ │ logical_in_cmd (直接分配) │ \u0026lt;- 可能不对齐 └──────────────────────────────────┘ 新分配（24字节）： ┌──────────────────────────────────────────────────┐ │ canary│ logical_in_cmd (偏移+8) │ canary│ │ (8B) │ (8B) │ (8B) │ └──────────────────────────────────────────────────┘ ↑ 强制对齐到16字节边界 机制2：缓冲溢出隔离 如果代码尝试越界写入： 写入后面缓冲时，会覆盖后Canary，而非其他数据结构 可以检测Canary值来发现溢出 防止了跨越到相邻内存块的污染 机制3：隐含的内存屏障效应 更大的分配可能改变内存分配器的行为 可能自动添加了保护页面 可能改变了缓存行对齐 3.3 修复有效性评估 修复方面 改进 影响 内存对齐 ✓✓✓ 确保16字节对齐 缓冲保护 ✓✓✓ 隔离越界访问 性能开销 ✓ 仅增加16字节 兼容性 ✓✓ 改善裸机和OS兼容性 可靠性 ✓✓✓ 解决U8类型问题 四、内存释放问题 4.1 当前释放代码的缺陷 位置：gcpnna_destroy_io_patch_info() 函数 (第1461-1473行)\n1 2 3 4 if (io_info-\u0026gt;logical_in_cmd != PNNA_NULL) { gcpnna_user_free_memory(io_info-\u0026gt;logical_in_cmd); // ❌ 释放的是已偏移的指针！ io_info-\u0026gt;logical_in_cmd = PNNA_NULL; } 4.2 问题剖析 1 2 3 4 5 6 7 8 9 10 11 分配时： alloc_base ──────────────┬────────────── [canary 8B] │[payload 8B][canary 8B] ↑ logical_in_cmd = alloc_base + 8 释放时应该： gcpnna_user_free_memory(alloc_base); // ✓ 释放原始指针 但代码做的是： gcpnna_user_free_memory(logical_in_cmd); // ❌ 释放偏移后的指针 4.3 后果 内存泄漏\n实际分配了24字节 只释放了前8字节（Canary部分） 丢失了后8字节的Canary和管理信息 分配器崩溃\n一些内存分配器依赖指针头部的元数据 释放偏移指针会破坏元数据 可能导致后续分配失败 未定义行为\n双重释放的风险 堆腐坏(Heap corruption) 五、完整修复方案 5.1 方案A：最小化修复（用户当前方案） 仅使用Canary保护，但留下释放问题\n1 2 3 // 优点：简单，立竿见影地解决U8问题 // 缺点：留下内存泄漏隐患 // 风险：长期运行可能堆崩溃 5.2 方案B：完整修复（推荐） 步骤1：扩展结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef struct _pnna_io_patch_info { pnna_uint32_t slice_num; pnna_address_t *logical_in_cmd; pnna_uint32_t *physical_in_cmd; pnna_uint32_t *offsets; pnna_uint32_t *transformation; pnna_uint32_t counter; pnna_uint32_t physical; pnna_uint8_t *logical; pnna_uint8_t **sw_op_buffer; pnna_buffer buffer; pnna_uint32_t patch_belong; // 新增：保存原始分配指针 void *logical_in_cmd_alloc_base; // ✓ 跟踪原始分配 } gcpnna_io_patch_info_t; 步骤2：修改分配代码 1 2 3 4 5 6 7 8 9 10 11 12 13 pnna_uint32_t payload_size = sizeof(pnna_address_t) * io_info-\u0026gt;slice_num; const pnna_uint32_t canary_bytes = sizeof(pnna_uint64_t); pnna_uint32_t alloc_size = payload_size + 2 * canary_bytes; void *alloc_base = PNNA_NULL; gcOnError(gcpnna_user_allocate_memory(alloc_size, (void **)\u0026amp;alloc_base)); // ✓ 保存原始指针 io_info-\u0026gt;logical_in_cmd_alloc_base = alloc_base; // 有效载荷位于前缀Canary之后 io_info-\u0026gt;logical_in_cmd = (pnna_address_t *)((pnna_uint8_t *)alloc_base + canary_bytes); gcpnna_user_zero_memory(io_info-\u0026gt;logical_in_cmd, payload_size); 步骤3：修改释放代码 1 2 3 4 5 if (io_info-\u0026gt;logical_in_cmd_alloc_base != PNNA_NULL) { gcpnna_user_free_memory(io_info-\u0026gt;logical_in_cmd_alloc_base); // ✓ 释放原始指针 io_info-\u0026gt;logical_in_cmd_alloc_base = PNNA_NULL; io_info-\u0026gt;logical_in_cmd = PNNA_NULL; } 六、为什么INT16不出问题，U8出问题 6.1 数据处理流程对比 INT16流程：\n1 2 3 4 5 6 7 8 9 INT16 NBG ↓ 较大数据块（2字节/元素） ↓ 处理次数较少 ↓ 内存访问模式相对宽松 ↓ 不触发硬件对齐异常 U8流程：\n1 2 3 4 5 6 7 8 9 U8 NBG ↓ 较小数据块（1字节/元素） ↓ 处理次数众多 ↓ 内存访问密集 ↓ 触发硬件对齐检查 6.2 C66X硬件特性 支持向量操作（SIMD） 对齐访问有严格要求 非对齐访问会: 导致性能下降 可能触发异常（某些配置） 在某些内存区域直接失败 6.3 内存分配器的行为差异 1 2 3 分配8字节时：可能返回未对齐指针 分配16字节时：分配器倾向于返回16字节对齐指针 分配24字节时：更可能满足硬件对齐要求 七、测试验证建议 7.1 功能测试 1 2 3 4 1. U8 NBG单层测试：✓ 已成功 2. U8 NBG多层测试：需要验证 3. INT16 NBG回归测试：✓ 需要确认无破坏 4. 混合U8/INT16测试：需要验证 7.2 内存检测 1 2 3 4 5 6 7 8 9 // 添加Canary检查（调试时） #define CHECK_CANARY(base_ptr, alloc_size) \\ do { \\ pnna_uint64_t *prefix = (pnna_uint64_t *)base_ptr; \\ pnna_uint64_t *suffix = (pnna_uint64_t *)((pnna_uint8_t *)base_ptr + alloc_size - 8); \\ if (*prefix != CANARY_VALUE || *suffix != CANARY_VALUE) { \\ gcpnna_error(\u0026#34;Canary corrupted! Buffer overflow detected!\u0026#34;); \\ } \\ } while(0) 7.3 长期运行测试 100,000+ 次分配/释放循环 监测是否有内存泄漏 监测堆使用趋势 八、总结对比 项目 原代码 修复后 改进 U8支持 ❌ 失败 ✓ 成功 +100% INT16 ✓ 成功 ✓ 成功 兼容 裸机 ❌ 失败 ✓ 成功 +100% RT-Thread ✓ 成功 ✓ 成功 兼容 内存对齐 不确定 保证 ✓✓✓ 缓冲保护 无 有 ✓✓✓ 内存泄漏 无 无（方案B） 安全 开销 最小 16B增加 \u0026lt;0.1% 九、建议行动 立即执行（高优先级） ✓ 采用Canary保护方案（已验证有效） ⚠️ 审计所有类似的内存分配代码 短期执行（中优先级） 扩展结构体，跟踪alloc_base 修改释放代码 添加单元测试 长期执行（低优先级） 考虑统一的内存管理框架 添加编译时对齐检查宏 文档记录裸机vs OS的差异 ","date":"2025-12-16T10:46:48+08:00","permalink":"https://xenithya.github.io/p/dsp_logical_cmd_error/","title":"Dsp_logical_cmd_error"},{"content":"04V 移植 RT-Thread 主要描述过程中遇到的相关问题和相关记录\n程序运行到浮点数时系统崩溃 总结 浮点数操作会导致系统崩溃由 MMU 初始化失败引发\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* mmu config */ struct mem_desc platform_mem_desc[] = { { 0x00000000, 0x00000000 + 0x00030000, 0x00000000, DEVICE_MEM }, { 0x30000000, 0x30B3FFFF, 0x30000000, DEVICE_MEM }, { 0x80000000, 0x80000000 + 0x7E000000, 0x80000000, NORMAL_MEM }, }; 参数解析 platform_mem_desc 数组定义了一系列内存区域的映射规则，供 MMU（内存管理单元）在系统启动时配置页表。数组中的每个结构体（struct mem_desc）通常包含四个关键参数：\n序号 参数名（通常约定） 示例值 含义 1 虚拟地址起始 (vaddr_start) 0x80000000 CPU 访问该内存区域时使用的虚拟地址的起始点。 2 虚拟地址结束 (vaddr_end) 0x80000000 + 0x7E000000 CPU 访问该内存区域时使用的虚拟地址的结束点（或紧随其后的地址）。 3 物理地址起始 (paddr_start) 0x80000000 该内存区域在实际硬件上的物理地址的起始点。 4 内存属性 (attr) NORMAL_MEM 定义该内存区域的访问特性和缓存策略。 内存属性总结 属性宏 描述 主要用途 缓存特性 DEVICE_MEM 设备内存 映射外设寄存器、不可缓存的片上 RAM 等。 不可缓存，每次读写直接操作硬件。 NORMAL_MEM 普通内存 映射主存储器（DRAM/SDRAM），存放代码、堆栈、数据等。 可缓存，由缓存机制加速访问。 参数地址说明 根据 04V 空间地址划分， \u0026lsquo;0x00000000 - 0x00030000\u0026rsquo; 为 arm 的私有空间 \u0026lsquo;0x30000000 - 0x30B3FFFF\u0026rsquo; 系统共享片上外设配置空间 \u0026lsquo;0x80000000 - 0xFFFFFFFF\u0026rsquo; 为 DDR 空间\n不同的板卡需要根据寄存器地址空间说明来配置\n定时器校准 计时不准确的问题 问题描述：\n系统中通过 rt_tick_get() 获取的时间与实际时间存在偏差，定时不准确。 分析发现，RT-Thread 内核时钟（tick）由 Generic Timer 提供中断驱动，而定时器频率配置错误导致 tick 周期不正确。\n问题原因：\ngtimer_set_counter_frequency() 中手动设置的 CNT_FREQUENCY（如 10MHz）与实际硬件计数器频率不一致。 gtimer_set_load_value() 参数使用了错误的步进值，导致 tick 中断周期计算错误。 确认硬件计数器频率 操作与分析：\n使用 gtimer_get_counter_frequency() 读取系统实际的定时器频率：\n1 2 timer_step = gtimer_get_counter_frequency(); rt_kprintf(\u0026#34;freqency %u MHz\\n\u0026#34;, timer_step / 1000000); 输出结果为：\n1 freqency 150 MHz 说明:\n该值来自 ARM 架构的 CNTFRQ 寄存器，表示 PL1 Physical Timer（Generic Timer） 的输入时钟频率。 该定时器为 ARM Cortex-A 系列（如 Cortex-A15）内置硬件定时器，与 CPU 主频相关但 通常经过分频，即定时器频率 ≤ CPU 主频。 修复方法 修复思路:\n使 RT-Thread 的 tick 中断周期与硬件计数频率严格匹配。\n具体修改:\n不再手动设置 CNTFRQ，保持硬件默认值：\n1 // gtimer_set_counter_frequency(CNT_FREQUENCY); // 删除此行 基于实际频率计算 tick 周期：\n1 2 timer_step = gtimer_get_counter_frequency() / RT_TICK_PER_SECOND; gtimer_set_load_value(timer_step); 中断服务函数保持一次重装载：\n1 2 3 4 5 6 7 8 9 10 11 void rt_hw_timer_isr(int vector, void *parameter) { rt_hw_interrupt_mask(GENERIC_TIMER_IRQ_NUM); arm_gic_clear_pending_irq(GENERIC_TIMER_ID0, GENERIC_TIMER_IRQ_NUM); arm_gic_clear_active(GENERIC_TIMER_ID0, GENERIC_TIMER_IRQ_NUM); rt_tick_increase(); // 通知RTT系统时间+1tick gtimer_set_load_value(timer_step); // 仅在ISR中重装载计数值 rt_hw_interrupt_umask(GENERIC_TIMER_IRQ_NUM); } 校准验证结果 验证方法:\n同时通过：\n硬件计数值：gtimer_get_counter() 内核tick：rt_tick_get() 分别计算时间间隔并对比。\n验证结果:\n两者计时结果完全一致，表明系统 tick 与硬件定时器周期完全同步，计时准确。\n补充说明 项目 说明 PL1 Physical Timer ARM Cortex-A 架构（如 A15）内置的 Generic Timer，寄存器包括 CNTFRQ、CNTP_TVAL、CNTP_CTL 等。 CPU 主频与定时器频率关系 定时器通常由主时钟分频得到，频率可能为主频的 1/2、1/4 等；由 SoC 硬件设计决定。 准确计时的关键 使用 __get_cntfrq() 获取真实频率，并以此计算每 tick 的装载值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int rt_hw_timer_init(void) { timer_step = gtimer_get_counter_frequency(); rt_kprintf(\u0026#34;freqency %u MHz\\n\u0026#34;, timer_step/1000000); timer_step = timer_step/RT_TICK_PER_SECOND; gtimer_set_load_value(timer_step); rt_hw_interrupt_install(GENERIC_TIMER_IRQ_NUM, rt_hw_timer_isr, RT_NULL, \u0026#34;tick\u0026#34;); rt_hw_interrupt_umask(GENERIC_TIMER_IRQ_NUM); GenericTimerInterruptEnable(GENERIC_TIMER_ID0); GenericTimerStart(GENERIC_TIMER_ID0); return 0; } INIT_BOARD_EXPORT(rt_hw_timer_init); ✅ 最终结论：:\n通过读取硬件实际计数频率（CNTFRQ）并以此计算每 tick 周期，RT-Thread 系统时钟与 ARM Generic Timer 完全同步，实现了高精度计时。\n-O2 优化下系统崩溃 💬 问题描述\n04V 适配 RTT 后，在 debug 模式下运行正常，但切换到 release 模式后，一旦运行浮点数操作，系统崩溃。 debug 和 release 模式就只有 O0 和 O2 的区别，当优化等级为 O1 时，系统也正常。 ✅ 分析过程\n对比了特定 GCC 版本和目标架构下，优化级别 -O1 和 -O2 分别启用了哪些具体的优化选项\n通过分别运行 arm-none-eabi-gcc -O1 -Q --help=optimizers 和 arm-none-eabi-gcc -O2 -Q --help=optimizers 并提供输出文件（O1_opts.txt 和 O2_opts.txt）实现了这一目标。 根据对比结果，将 仅属于 -O2 的大量优化选项 手动添加到其 rtconfig.py 配置文件的 -O1 编译标志中。 报告了一个特定的运行时错误：程序在 -O0 和 -O1 下运行正常，但在 -O2 下系统崩溃。 发现通过禁用 -O2 选项列表中的 -fschedule-insns2 优化后，系统能够正确运行。 ✅ 临时解决方法\n在 release 模式下，编译标志中添加 -fno-schedule-insns2，以临时禁用导致崩溃的指令调度优化。\n开启 neno-vfpv4 会导致系统崩溃 问题描述与初步诊断 初始现象: 系统启动时，使用 04v 等指令初始化 VFP/NEON 单元的寄存器（CPACR、NSACR、FPEXC）后，打印 VFP/NEON 状态为“✅启用”。但在 RT-Thread 开始 do components initialization 阶段或首次线程切换时，系统进入无限的 backtrace: 打印循环（硬错误/异常）。\n关键发现: 将编译器参数从 -mfpu=neon-vfpv4 改为 -mfpu=vfpv4 后，系统可正常运行。\n诊断结论: 问题不在于 VFP/NEON 单元的**启用（Enable）**本身，而是出在 NEON 相关的上下文保存与恢复逻辑上。VFPv4 仅使用 D0-D15 寄存器，而 NEON/VFPv4 使用 D0-D31 全套 32 个 D 寄存器。因此，问题集中在 D16-D31 的处理上。\n根源分析（基于 RT-Thread 源码） 通过分析 RT-Thread 的汇编上下文切换文件 (context_gcc.S) 和栈初始化文件 (stack.c)，定位到两个核心错误：\n错误原因一：FPU 栈帧空间预留不足 (堆栈溢出/错位)：\n汇编要求 (context_gcc.S): 在 FPU 启用时，上下文切换代码 (rt_hw_context_switch_exit 的恢复逻辑) 会尝试从栈上恢复 66 个 32 位字 (264 字节) 的 FPU 上下文： D0-D31 寄存器：32 个 64 位寄存器 = 64 个 32 位字 FPSCR 寄存器：1 个 32 位字 FPEXC 寄存器：1 个 32 位字 原始 stack.c 缺陷: rt_hw_stack_init 函数中 #ifdef RT_USING_FPU 部分，只预留了一个 4 字节的字 (*(--stk) = 0;)，远小于实际所需的 264 字节。 后果: 第一次线程切换时，栈指针被严重错位，导致 CPU 加载错误的 PC/LR 寄存器值，从而跑飞或进入 Hard Fault。 错误原因二：FPU 栈帧压栈顺序与对齐错误：\n即使修正了空间不足的问题，如果不按照汇编的恢复顺序来初始化栈帧，或者未满足 ARM EABI 的 8 字节对齐要求，系统仍会崩溃。\n压栈顺序错误: context_gcc.S 中的 FPU 寄存器恢复顺序是：FPEXC → FPSCR → D16-D31 → D0-D15。 因此，rt_hw_stack_init 的 压栈顺序（从高地址到低地址） 必须是反序的：D0-D15 → D16-D31 → FPSCR → FPEXC。 8 字节对齐错误: 通用寄存器栈帧（17 个字） + FPU 栈帧（66 个字） = 83 个字 (332 字节)。 $332$ 字节不是 $8$ 的倍数，导致栈指针 4 字节错位，违反了 NEON/64 位数据操作的对齐要求，最终导致 Data Abort 或跑飞。 最终解决办法 修正 rt_hw_stack_init：\n解决问题的核心在于修正 stack.c 中的 rt_hw_stack_init 函数，确保正确的空间、正确的顺序和正确的对齐。\nC 代码修改 (在 stack.c 中)：\n将 rt_hw_stack_init 函数中的 #ifdef RT_USING_FPU 块替换为以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #ifdef RT_USING_FPU /* VFP/NEON Context (共 66 个 32 位字 = 264 字节) */ /* 1. D0-D15 */ for (i = 0; i \u0026lt;= 15; i++) { *(--stk) = 0x00000000; *(--stk) = 0x00000000; } /* 2. D16-D31 */ for (i = 16; i \u0026lt;= 31; i++) { *(--stk) = 0x00000000; *(--stk) = 0x00000000; } /* 3. FPSCR */ *(--stk) = 0x00000000; /* 4. FPEXC: EN=1 */ *(--stk) = 0x40000000; #endif 配置调整 编译器参数: 确保使用正确的 NEON 选项： ' -mfloat-abi=hard' ' -mfpu=neon-vfpv4' 栈大小: 由于 FPU 栈帧增加了 268 字节，强烈建议将所有线程的栈大小（如 RT_MAIN_THREAD_STACK_SIZE）适当增加，例如从 2048 调整到 3072 或 4096，以避免线程启动失败（堆分配不足）。 问题 为什么通过寄存器填：0xdeadbeef，而 D0-D15 填0x00000000？\n通用寄存器 (R4-R12, LR, PC 等)： 我们通常用 0xdeadbeef 或其他模式值初始化。 0xdeadbeef 是一个调试辅助标记，它的值本身对程序的正确运行没有影响。 浮点寄存器（D0-D31）和通用寄存器有着本质的区别：它们保存的是数据，而不是控制流或调试标记。 浮点寄存器： 用 0x00000000 来保证数据符合 IEEE 754 规范，并避免在新线程启动时立即触发浮点异常。 开启硬件浮点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #define NSACR_VFP_ACCESS (3 \u0026lt;\u0026lt; 10) // CP10/CP11 bits: [11:10] = 0b11 (Enable Non-secure access) #define NSACR_NSASEDIS_MASK (3 \u0026lt;\u0026lt; 14) // NSASEDIS bit: [15] #define NSACR_CP10_CP11 (NSACR_VFP_ACCESS) // 0x0C00 void enable_nsacr(void) { unsigned int r0; // 1. 读取 NSACR: MRC p15, 0, r0, c1, c1, 2 __asm__ __volatile__( \u0026#34;mrc p15, 0, %0, c1, c1, 2\u0026#34; : \u0026#34;=r\u0026#34; (r0) // Output : // No Input : \u0026#34;memory\u0026#34; // Clobber list ); // 2. ORR r0, r0, #(3\u0026lt;\u0026lt;10) ; Enable Non-secure access to CP10 and CP11 (0x0C00) // 3. BIC r0, r0, #(3\u0026lt;\u0026lt;14) ; Clear NSASEDIS bit (0xC000) r0 = (r0 | NSACR_CP10_CP11) \u0026amp; (~NSACR_NSASEDIS_MASK); // 4. 写入 NSACR: MCR p15, 0, r0, c1, c1, 2 __asm__ __volatile__( \u0026#34;mcr p15, 0, %0, c1, c1, 2\u0026#34; : // No Output : \u0026#34;r\u0026#34; (r0) // Input : \u0026#34;memory\u0026#34; ); // 5. ISB (Instruction Synchronization Barrier) __asm__ __volatile__(\u0026#34;isb\u0026#34; ::: \u0026#34;memory\u0026#34;); } #define CPACR_FULL_ACCESS (0x3 \u0026lt;\u0026lt; 20) // CP10 field: [21:20] = 0b11 (Full Access) #define CPACR_FULL_ACCESS_EXT (0x3 \u0026lt;\u0026lt; 22) // CP11 field: [23:22] = 0b11 (Full Access) #define CPACR_VFP_NEON (CPACR_FULL_ACCESS | CPACR_FULL_ACCESS_EXT) // 0x00F00000 void enable_cpacr(void) { unsigned int r0 = CPACR_VFP_NEON; // r0 = 0x00F00000 // 1. 写入 CPACR: MCR p15, 0, r0, c1, c0, 2 __asm__ __volatile__( \u0026#34;mcr p15, 0, %0, c1, c0, 2\u0026#34; : // No Output : \u0026#34;r\u0026#34; (r0) // Input : \u0026#34;memory\u0026#34; ); // 2. ISB __asm__ __volatile__(\u0026#34;isb\u0026#34; ::: \u0026#34;memory\u0026#34;); } #define FPEXC_EN_BIT (1 \u0026lt;\u0026lt; 30) // EN bit [30] = 1 (Enable) void enable_fpexc(void) { unsigned int r3 = FPEXC_EN_BIT; // r3 = 0x40000000 // 1. 写入 FPEXC: VMSR FPEXC, r3 // 注意：VMSR 是 VFP/NEON 指令，需要特殊处理，通常使用伪指令或编码 // 在 GCC 内联汇编中，直接使用 VFP 伪指令 `vmsr` 即可。 __asm__ __volatile__( \u0026#34;vmsr fpexc, %0\u0026#34; : // No Output : \u0026#34;r\u0026#34; (r3) // Input : \u0026#34;memory\u0026#34; ); } void arm_vfp_neon_enable(void) { // 1. 配置 NSACR (非安全访问控制) enable_nsacr(); // 2. 配置 CPACR (协处理器访问控制) enable_cpacr(); // 3. 配置 FPEXC (全局启用 VFP/NEON) enable_fpexc(); } /** * @brief 确认 VFP/NEON 启用状态 * * 通过读取 CPACR, NSACR, 和 FPEXC 寄存器来验证配置是否正确。 */ void arm_vfp_neon_check_status(void) { unsigned int cpacr_val, nsacr_val, fpexc_val; // --- 1. 读取 CPACR (c1, c0, 2) --- __asm__ __volatile__( \u0026#34;mrc p15, 0, %0, c1, c0, 2\u0026#34; : \u0026#34;=r\u0026#34; (cpacr_val) : : \u0026#34;memory\u0026#34; ); // --- 2. 读取 NSACR (c1, c1, 2) --- __asm__ __volatile__( \u0026#34;mrc p15, 0, %0, c1, c1, 2\u0026#34; : \u0026#34;=r\u0026#34; (nsacr_val) : : \u0026#34;memory\u0026#34; ); // --- 3. 读取 FPEXC (VFP/NEON 寄存器) --- // 注意：FPEXC 寄存器通过 VMRS 指令访问，需要 VFP 处于某种工作状态。 __asm__ __volatile__( \u0026#34;vmrs %0, fpexc\u0026#34; : \u0026#34;=r\u0026#34; (fpexc_val) : : \u0026#34;memory\u0026#34; ); printf(\u0026#34;--- VFP/NEON ---\\n\u0026#34;); printf(\u0026#34;CPACR (c1, c0, 2) Value: 0x%08X\\n\u0026#34;, cpacr_val); printf(\u0026#34;NSACR (c1, c1, 2) Value: 0x%08X\\n\u0026#34;, nsacr_val); printf(\u0026#34;FPEXC Value: 0x%08X\\n\u0026#34;, fpexc_val); printf(\u0026#34;------------------------------\\n\u0026#34;); // --- 4. 检查关键位 --- // 期望 CPACR 中的 CP10/CP11 (位 [23:20]) 为 0b1111 (0xF) // 0x00F00000 检查 if ((cpacr_val \u0026amp; 0x00F00000) == 0x00F00000) { printf(\u0026#34;CPACR Status: ✅ CP10/CP11 Full Access Enabled (Secure)\\n\u0026#34;); } else { printf(\u0026#34;CPACR Status: ❌ CP10/CP11 Access NOT Fully Enabled (Expected 0x00F00000 set)\\n\u0026#34;); } // 期望 NSACR 中的 CP10/CP11 (位 [11:10]) 为 0b11 (0xC00) // 并且 NSASEDIS (位 [15]) 为 0 if ((nsacr_val \u0026amp; 0x00000C00) == 0x00000C00 \u0026amp;\u0026amp; (nsacr_val \u0026amp; 0x00008000) == 0) { printf(\u0026#34;NSACR Status: ✅ Non-secure CP10/CP11 Access Enabled\\n\u0026#34;); } else { printf(\u0026#34;NSACR Status: ❌ Non-secure Access NOT Enabled\\n\u0026#34;); } // 期望 FPEXC 中的 EN 位 (位 30) 为 1 (0x40000000) if (fpexc_val \u0026amp; 0x40000000) { printf(\u0026#34;FPEXC Status: ✅ VFP/NEON Global Enable (EN) Set\\n\u0026#34;); } else { printf(\u0026#34;FPEXC Status: ❌ VFP/NEON Global Enable (EN) NOT Set\\n\u0026#34;); } } 查看标量/向量浮点指令 1 2 3 4 5 6 7 8 9 # 可以这样查看标量 VFP 指令： arm-none-eabi-objdump -d rtthread-a15.elf | findstr vadd arm-none-eabi-objdump -d rtthread-a15.elf | findstr vldr arm-none-eabi-objdump -d rtthread-a15.elf | findstr vmul arm-none-eabi-objdump -d rtthread-a15.elf | findstr vstr arm-none-eabi-objdump -d rtthread-a15.elf | findstr vcmp arm-none-eabi-objdump -d rtthread-a15.elf |findstr vst1 arm-none-eabi-objdump -d rtthread-a15.elf |findstr vld1 串口有输出无输入 在 FTDOC4614B_FT-M7004V 片上集成外设使用手册.pdf 中\n2.2.1.7 IRQSn 寄存器 章节介绍：\n1 2 3 中断（ IRQSn）用来记录 CLC 发送给 ARM 核的可以屏蔽中断，该寄存器可读写，通 过对其写 1 软件清除对应的中断事件标志（标志位清 0），写 0 无效。 224 个外设中断 事件 IRQs 共用 7 个中断标志寄存器（ IRQ0~IRQ6）。 2.2.2 寄存器列表 章节介绍：\n1 2 3 4 5 6 7 8 CIC 内部有丰富的寄存器， CIC 完成外设中断到 DSP、 ARM 或 DMA 的路由都是通过 对这些内部寄存器进行正确的配置来处理的。 CIC 内部具体的寄存器如表 18 所示：其 寄存器的基地址为 0x30040000。 偏移地址 寄存器名称 描述 ... 0x1008 ARM_IRQS0 IRQ0状态寄存器 ... 因此，需要写 1 软件清除对应的中断事件标志，具体实现如下所示：\n在 serial/fpl011 的 FPl011InterruptHandler 中断处理函数中\n1 2 3 u32 reg_value2 = *(volatile u32 *)0x30041008; volatile u32 *local_addr = (volatile u32 *)0x30041008; *local_addr = reg_value2; 清除中断事件标志。\n优化后：\n1 2 3 4 5 6 7 // parameters.h #define CIC_IRSQ0_OFFSET 0x1008 // fpl011_intr.c #include \u0026#34;parameters.h\u0026#34; reg_value = FUART_READREG32(CIC_BASE, CIC_IRSQ0_OFFSET); FUART_WRITEREG32(CIC_BASE, CIC_IRSQ0_OFFSET, reg_value); rt-thread-v5.1.0 修改内容 消除警告 components/net/lwip/port/ethernetif.c : 584\n1 2 3 4 /* set name */ // rt_strncpy(netif-\u0026gt;name, name, NETIF_NAMESIZE); rt_strncpy(netif-\u0026gt;name, name, NETIF_NAMESIZE - 1); netif-\u0026gt;name[NETIF_NAMESIZE - 1] = \u0026#39;\\0\u0026#39;; components/net/netdev/src/netdev.c : 100\n1 2 3 4 5 /* fill network interface device */ // rt_strncpy(netdev-\u0026gt;name, name, RT_NAME_MAX); rt_strncpy(netdev-\u0026gt;name, name, RT_NAME_MAX - 1); netdev-\u0026gt;name[RT_NAME_MAX - 1] = \u0026#39;\\0\u0026#39;; netdev-\u0026gt;user_data = user_data; src/object6.c : 384\n1 2 3 4 5 6 7 #if RT_NAME_MAX \u0026gt; 0 // rt_strncpy(object-\u0026gt;name, name, RT_NAME_MAX); /* copy name */ rt_strncpy(object-\u0026gt;name, name, RT_NAME_MAX - 1); object-\u0026gt;name[RT_NAME_MAX - 1] = \u0026#39;\\0\u0026#39;; #else object-\u0026gt;name = name; #endif /* RT_NAME_MAX \u0026gt; 0 */ bug 修复 libcpu/arm/cortex-a/cpuport.h\n1 2 3 4 /* VFP/NEON register count for FPU context */ #ifndef VFP_DATA_NR #define VFP_DATA_NR 64 /* 32 double-precision registers = 64 words */ #endif libcpu/arm/cortex-a/stack.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) { rt_uint32_t *stk; #ifdef RT_USING_FPU rt_uint32_t i; #endif stack_addr += sizeof(rt_uint32_t); stack_addr = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stack_addr, 8); stk = (rt_uint32_t *)stack_addr; *(--stk) = (rt_uint32_t)_thread_start; /* entry point */ *(--stk) = (rt_uint32_t)texit; /* lr */ *(--stk) = 0xdeadbeef; /* r12 */ *(--stk) = 0xdeadbeef; /* r11 */ *(--stk) = 0xdeadbeef; /* r10 */ *(--stk) = 0xdeadbeef; /* r9 */ *(--stk) = 0xdeadbeef; /* r8 */ *(--stk) = 0xdeadbeef; /* r7 */ *(--stk) = 0xdeadbeef; /* r6 */ *(--stk) = 0xdeadbeef; /* r5 */ *(--stk) = 0xdeadbeef; /* r4 */ *(--stk) = 0xdeadbeef; /* r3 */ *(--stk) = 0xdeadbeef; /* r2 */ *(--stk) = (rt_uint32_t)tentry; /* r1 : argument 2 for trampoline */ *(--stk) = (rt_uint32_t)parameter; /* r0 : argument 1 */ /* cpsr */ if ((rt_uint32_t)tentry \u0026amp; 0x01) *(--stk) = SVCMODE | 0x20; /* thumb mode */ else *(--stk) = SVCMODE; /* arm mode */ #ifdef RT_USING_SMART *(--stk) = 0; /* user lr */ *(--stk) = 0; /* user sp*/ #endif #ifdef RT_USING_FPU /* FPU context initialization matches context_gcc.S restore order: * Stack layout (high to low): FPEXC -\u0026gt; FPSCR -\u0026gt; D16-D31 -\u0026gt; D0-D15 */ stk -= VFP_DATA_NR; rt_memset(stk, 0, VFP_DATA_NR * sizeof(rt_uint32_t)); /* Initialize D0-D31 (64 words for 32 double regs) */ *(--stk) = 0; /* FPSCR: Floating-Point Status and Control Register */ *(--stk) = 0x40000000; /* FPEXC: Enable FPU (bit 30 = EN) */ #endif return (rt_uint8_t *)stk; } ","date":"2025-11-07T09:15:41+08:00","permalink":"https://xenithya.github.io/p/04v_rtt/","title":"04V_RTT"},{"content":"rtconfig.py 说明：此文档基于 rtconfig.py 的整理而成。包含每一项编译参数详解（逐项、逐标志说明）\n基本元信息 ARCH = 'arm'\n表示目标架构为 ARM。 CPU = 'cortex-a15'\n目标 CPU 型号（用于优化与 -mcpu 指定）。 CROSS_TOOL = 'gcc' / PLATFORM = 'gcc'\n指定使用 GCC 家族的交叉工具链（SCons 脚本会据此选择命令模板）。 BUILD = 'release' 或 'debug'\n构建模式开关：debug 启用符号与低优化；release 启用高优化、去除调试信息。 EXEC_PATH\n工具链可执行文件目录（例如 arm-none-eabi-gcc 所在路径）。 工具链命令前缀与命令 PREFIX = 'arm-none-eabi-'\n工具链命令的前缀，最后构成 arm-none-eabi-gcc、arm-none-eabi-ar 等。 CC = PREFIX + 'gcc'\nC/C++ 编译器命令（用于 .c 编译与链接）。 AS = PREFIX + 'gcc'\n用 GCC 调用汇编器 (通常用 gcc -x assembler-with-cpp 去预处理并汇编 .S)；用 GCC 当作汇编器可以统一参数解析方式。 AR = PREFIX + 'ar'\n归档工具（创建静态库 .a）。 LINK = PREFIX + 'gcc'\n链接器前端，通常用 gcc 调用 ld，以便自动添加启动文件和标准库路径（若有）。 SIZE, OBJDUMP, OBJCPY\nSIZE：打印 ELF 大小； OBJDUMP：反汇编/生成汇编视图； OBJCPY：在编译后导出 .bin（或其他格式）。 TARGET_EXT = 'elf'\n最终目标文件扩展名（ELF）。 LINK_SCRIPT = 'link_ram.lds'\n链接脚本文件名，定义内存布局（.text/.data/.bss 等段放置）。 DEVICE（全局目标/体系特性，一般拼接到各类 flags） DEVICE 是对 CPU/浮点/编译器行为的集中声明，通常在 CFLAGS/AFLAGS/LFLAGS 中被复用。我们在重构版中将其写成：\n1 2 3 4 5 6 7 8 9 DEVICE = ( \u0026#39; -mcpu=cortex-a15\u0026#39; \u0026#39; -mfpu=neon-vfpv4\u0026#39; # or \u0026#39;vfpv4\u0026#39; 详见说明 \u0026#39; -mfloat-abi=hard\u0026#39; \u0026#39; -ftree-vectorize\u0026#39; \u0026#39; -ffast-math\u0026#39; \u0026#39; -funwind-tables\u0026#39; \u0026#39; -fno-strict-aliasing\u0026#39; ) 以下为每个子项逐条解释：\n-mcpu=cortex-a15\n指定目标 CPU，允许编译器生成针对该 CPU 的指令序列与调度策略（包括内建函数的实现）。 -mfpu=... (vfpv4 或 neon-vfpv4)\n指定使用哪个浮点/向量单元指令集： vfpv4：仅标量浮点指令（适合仅用 FPU 的场景）； neon-vfpv4：包含 NEON SIMD 指令，编译器可能生成向量化指令以提升性能。 注意：若使用 neon-vfpv4，需要确保启动代码启用 NEON 并在上下文切换时保存/恢复相应寄存器（否则会崩溃）。 -mfloat-abi=hard\n指定编译器使用硬件浮点 ABI（函数参数通过浮点寄存器传递），需与链接的运行时/库一致（常见于裸机与高性能场景）。 -ftree-vectorize\n启用自动向量化优化（GCC 的树优化阶段），在支持 NEON 时可生成 SIMD 指令加速循环等。 -ffast-math\n放宽 IEEE 浮点标准以允许更激进的浮点优化（可能影响数值精度/异常），通常在追求性能时使用需谨慎。 -funwind-tables\n生成栈展开表以支持异常处理、回溯信息或调试时打印调用栈；也利于 post-mortem 分析。 -fno-strict-aliasing\n关闭严格别名优化，避免编译器基于别名规则重排导致未定义行为（在嵌入式 C 代码里常见指针转换场景）。 CFLAGS（用于 .c 文件编译） CFLAGS 在重构版中示例为：\n1 CFLAGS = DEVICE + \u0026#39; -ffunction-sections -fdata-sections -Wall -Wno-cpp ... -mno-unaligned-access -D_POSIX_SOURCE\u0026#39; 逐条解释：\nDEVICE\n把上面 DEVICE 中的所有通用选项拼接到 C 编译器中。 -ffunction-sections / -fdata-sections\n让每个函数和每个全局变量/常量放到独立的段中（如 .text.func_name、.data.var），方便链接器通过 --gc-sections 丢弃未使用的函数/数据，减小固件体积。 -Wall\n打开一组常见警告，帮助捕获潜在错误。 -Wno-*（多个）\n关闭特定告警（如 -Wno-unused-variable 等），是为了在较旧或特殊代码库中减少噪音。建议按需缩减，以免屏蔽真正的问题。 -mno-unaligned-access\n禁用非对齐访问（使编译器避免生成非对齐访问指令），某些 ARM SoC 在非对齐访问会产生异常或性能问题。 -D_POSIX_SOURCE\n定义 POSIX 宏，启用 POSIX 兼容性相关声明（如果工程依赖 POSIX 特性）。 在 if BUILD == 'debug' 下追加 -O0 -g：\n-O0：关闭优化，便于单步调试； -g：生成 DWARF 调试信息，调试器显示源码、变量名等。 在 else（release）下追加 -O2 -fno-schedule-insns2：\n-O2：常用的性能优化等级； -fno-schedule-insns2：关闭 GCC 的第二阶段指令调度（在某些 ARM 平台上可避免因为过度调度导致的浮点或中断问题）。 AFLAGS（用于汇编文件 .S / .s） AFLAGS 在重构版示例为：\n1 AFLAGS = DEVICE + \u0026#39; -ffunction-sections -fdata-sections -x assembler-with-cpp -D__ASSEMBLY__ -c\u0026#39; 逐条解释：\nDEVICE\n将 -mcpu、-mfpu、-mfloat-abi 等全局选项也应用到汇编编译阶段。注意如果 DEVICE 中使用 neon-vfpv4，则汇编与 C 代码都会可能使用 NEON 指令。 -ffunction-sections -fdata-sections\n虽然对汇编文件影响有限，但保证与 C 文件一致的段布局，有助于链接器精确处理节（section）。 -x assembler-with-cpp\n把源文件当作带 C 预处理器的汇编文件处理，允许在汇编中使用 #include、#ifdef 等预处理指令（常见于 start.S）。 -D__ASSEMBLY__\n在包含头文件时通知其处于汇编上下文，避免将 C 语义代码（如函数声明）纳入汇编中。 -c\n只编译（产出 .o），不链接。 在 debug 模式下追加 -g\n使 .S 编译的目标文件包含调试符号，便于在汇编层次使用 GDB 单步、断点与反汇编对应源，便于调试启动、异常与上下文切换等底层逻辑。 LFLAGS（链接选项） LFLAGS 示例为：\n1 LFLAGS = DEVICE + \u0026#39; -specs=nosys.specs -Wl,--gc-sections,-Map=rtthread.map,-cref -Wl,-u,system_vectors,--wrap=memcpy -T \u0026#39; + LINK_SCRIPT + \u0026#39; -static -lm\u0026#39; 逐项说明：\nDEVICE\n把 CPU/FPU 信息告知链接器相关的运行时库选择与内联实现（在某些情况下影响链接器对内建函数的选择）。 -specs=nosys.specs\n使用 nosys.specs 禁用对底层系统调用（syscalls）的默认依赖，适用于裸机/RTOS 环境，避免链接 libc 中需要底层 OS 的部分。 -Wl,--gc-sections\n将 --gc-sections 传给链接器 ld，与 -ffunction-sections / -fdata-sections 配合，删除未使用的代码/数据，减小固件体积。 -Wl,-Map=rtthread.map,-cref\n生成链接 map 文件（rtthread.map），并在 map 中包含交叉引用信息（-cref），方便定位符号与内存布局。 -Wl,-u,system_vectors\n强制链接器将 system_vectors 当作未定义符号（需要被解析），常用于确保中断向量或某些弱符号被链接进来。 -Wl,--wrap=memcpy\n启用链接器对 memcpy 的包装支持（--wrap=symbol），链接器在遇到对 memcpy 的调用时会用 __wrap_memcpy 替代，若需要可以提供替代实现或做跟踪/替换。 -T link_ram.lds\n明确指定链接脚本，告诉链接器如何把段放到物理地址（RAM/FLASH）中。 -static\n静态链接，避免对共享库的依赖（裸机/嵌入式常用）。 -lm\n链接 libm（数学库），若使用数学函数需要该库。 DUMP_ACTION 与 POST_ACTION（构建后动作） DUMP_ACTION = OBJDUMP + ' -D -S $TARGET \u0026gt; rtthread.asm\\n'\n在构建后自动对 ELF 进行反汇编并带源代码注释输出到 rtthread.asm，便于审查生成代码。 POST_ACTION = OBJCPY + ' -O binary $TARGET rtthread.bin\\n' + SIZE + ' $TARGET \\n'\n将 ELF 导出为裸二进制 rtthread.bin 以便烧写，并打印 ELF 大小信息。 总结 1 2 3 4 Compilation Flags: arm-none-eabi-gcc [CFLAGS] file.c -o file.o arm-none-eabi-gcc [AFLAGS] file.S -o file.o arm-none-eabi-gcc [LFLAGS] *.o -o rtthread-a15.elf 关于浮点单元（vfpv4 vs neon-vfpv4）的实践建议（回顾） 默认稳妥方式： DEVICE 使用 -mfpu=vfpv4 -mfloat-abi=hard。\n优点：语言级浮点运算使用硬件 FPU，避免 NEON 指令带来的上下文开销或未启用问题。 如果需要 NEON 加速（全局）：将 DEVICE 改为 -mfpu=neon-vfpv4 -mfloat-abi=hard 只有在满足以下前提时才安全：\n启动代码（start.S）在早期明确启用 NEON/FPU 单元（设置 CPACR/FPEXC 等寄存器）； 上下文切换代码保存/恢复 NEON 寄存器（q0–q15 / d0–d31）； 你理解并接受 NEON 指令所带来的堆栈/任务切换开销。 折中做法：保留 DEVICE 为 vfpv4，在需要的汇编文件（如手写优化函数）中单独使用 -mfpu=neon-vfpv4（即在 AFLAGS 或单文件级别覆盖），并在该汇编文件中做必要的寄存器保存/恢复与初始化。\n常见问题速查（FAQ） Q：AFLAGS 在 release 模式下完全没用？\nA：不是。AFLAGS 始终用于编译 .S 文件。release 模式只是没有向 AFLAGS 里追加 -g，但 AFLAGS 的默认内容仍然生效。 Q：C 文件生成汇编时会用 AFLAGS 吗？\nA：不会。C 编译器内部生成汇编时使用 CFLAGS 控制行为。AFLAGS 只对源文件类型为汇编（.S / .s）时生效。 Q：把 DEVICE 里的 -mfpu 改为 neon-vfpv4 直接会导致崩溃？\nA：如果启动/上下文切换代码未做好相应变更，可能导致异常或任务切换破坏。需按建议在启动与上下文中启用/保存 NEON。 六、后续建议（可选） 在 rtconfig.py 顶部添加注释说明（例如 # NOTE: AFLAGS only used for .S files; CFLAGS used for .c files）。 精简 -Wno-* 列表，仅保留确实需要屏蔽的警告，长期看能发现潜在问题。 如果决定启用 neon-vfpv4 全局支持，请让我生成一段可插入 start.S 的安全 NEON 启用片段，并提供 context 保存/恢复代码示例。 ","date":"2025-11-05T15:40:47+08:00","permalink":"https://xenithya.github.io/p/rtconfig_explanation/","title":"Rtconfig_explanation"},{"content":"Sphinx + Doxygen生成html Doxygen 是一款开源的跨平台文档生成工具，主要用于从带有特定格式注释的源代码中提取信息，自动生成结构化文档。它支持多种编程语言（如 C、C++、Java、Python 等），并能生成 HTML、PDF、LaTeX、RTF 等多种格式的文档。一般建议让 Doxygen 只看头文件，避免扫描 .c/.cpp 文件中重复定义。\n基础工具安装 Doxygen 核心工具 1 2 sudo apt-get install doxygen # Debian/Ubuntu sudo yum install doxygen # Fedora/CentOS ​​辅助工具（可选但推荐） Graphviz​​：用于生成类图、调用关系图等可视化内容： 1 2 3 4 # Windows：勾选安装或单独下载 # Linux/macOS： sudo apt-get install graphviz # Linux brew install graphviz # macOS LaTeX​​（生成 PDF 文档）： 1 2 3 4 5 # Windows：安装 MiKTeX（官网下载） # Linux： sudo apt-get install texlive-full # macOS： brew install --cask mactex 配置文件生成 在项目根目录运行命令：\n1 2 doxygen -g #或者 doxygen -s -g Doxyfile 生成默认 Doxyfile\n核心配置 ​项目信息 1 2 3 PROJECT_NAME = \u0026#34;My Project\u0026#34; # 项目名称 PROJECT_NUMBER = \u0026#34;1.0\u0026#34; # 版本号 OUTPUT_LANGUAGE = Chinese # 输出语言（支持中文） 输入与输出路径 1 2 3 INPUT = ./src # 源码路径 RECURSIVE = YES # 递归搜索子目录 OUTPUT_DIRECTORY = ./docs # 输出目录 输出格式 1 2 3 GENERATE_HTML = YES # 生成 HTML GENERATE_LATEX = NO # 关闭 LaTeX（需 PDF 时设为 YES） HAVE_DOT = YES # 启用 Graphviz 图表 注释提取规则 1 2 EXTRACT_ALL = YES # 提取所有代码元素（即使无注释） FILE_PATTERNS = *.c *.h *.cpp # 处理指定扩展名的文件 启用 XML 生成功能 1 2 GENERATE_XML = YES # 启用XML输出（默认NO，必须显式设为YES） XML_OUTPUT = xml # 指定XML文件输出目录（默认在OUTPUT_DIRECTORY下生成xml文件夹） 确保代码提取完整性 1 2 3 EXTRACT_ALL = YES # 提取所有类/函数，即使无注释 EXTRACT_PRIVATE = YES # 提取私有成员 EXTRACT_STATIC = YES # 提取静态成员 生成图表或交叉引用 1 HAVE_DOT = YES # 依赖Graphviz生成关系图 通过别名注册自定义指令 定义 ALIASES，将 @xun 映射为合法指令： 1 ALIASES += \u0026#34;xun=@note 开发者：\\n\u0026#34; 宏是否被提取 1 2 3 4 5 MACRO_EXPANSION = YES EXPAND_ONLY_PREDEF = NO # 是否启用了对 #define 的提取 ENABLE_PREPROCESSING = YES 验证与使用 生成文档:\n1 doxygen Doxyfile 常见问题与解决办法 函数指针或数组参数被错误解析为基础类型 ❓ 问题描述\n函数声明如下：\n1 int nn_infer_only(nn_context *context, nn_tensor input_buffer[]); 通过 Sphinx + Breathe 渲染后，.rst 中变成：\n1 .. doxygenfunction:: nn_infer_only(nn_context *, nn_tensor) input_buffer[] 被错误解析为 nn_tensor，造成文档描述不准确。\n✅ 解决办法\n确保 Doxygen 配置文件中启用以下选项：\n1 OPTIMIZE_OUTPUT_FOR_C = YES 该选项告诉 Doxygen 以 C 语言语法风格解析参数（特别是数组、指针和函数参数列表），避免将数组误解为单个类型。\n我的解决办法是通过将 nn_tensor input_buffer[] 改为 nn_tensor *input_buffer\n函数使用 __attribute__ 报错 ❓ 问题描述\n定义如下函数：\n1 void print_msg(const char *format, ...) __attribute__((format(printf, 1, 2))); 报错信息：\n1 2 3 Unable to resolve function \u0026#34;print_msg\u0026#34; with arguments \u0026#34;(const char*, ...)\u0026#34; ... Error in declarator or parameters-and-qualifiers ✅ 解决办法\n在 Doxygen 配置文件 Doxyfile 中添加：\n1 PREDEFINED += __attribute__(x)= 这样 Doxygen 在预处理阶段会忽略 GNU 扩展的 __attribute__，避免解析失败。\nDuplicate C++ declaration 警告：结构体重复声明 ❓ 问题描述\n当存在以下代码：\n1 2 typedef struct detection detection; struct detection { ... }; Doxygen 与 Breathe 会为 struct detection 和 typedef detection 各生成一份文档，导致警告：\n1 2 WARNING: Duplicate C++ declaration, also defined at ... Declaration is \u0026#39;.. cpp:type:: struct detection detection\u0026#39;. ✅ 解决办法\n在 Doxyfile 中添加：\n1 TYPEDEF_HIDES_STRUCT = YES 启用该选项后，Doxygen 在发现 typedef 与 struct 同名时只生成一份文档，避免重复。\n我的解决办法是将：\n1 2 3 typedef struct box { float x, y, w, h; } box; 改为：\n1 2 3 typedef struct _box { float x, y, w, h; } box; 4. 清理缓存以解决重复定义或无效变更 ❓ 问题描述\n明明修改了 .h 文件或 Doxyfile，但生成文档仍然出现旧的内容或重复定义。\n✅ 解决办法\n清理生成目录：\n1 2 3 4 # 示例： rm -rf build/xml # 清除 Doxygen XML 输出 rm -rf source/pnna/pnna_api/*.rst # 清除旧的 .rst make clean html # 重新构建文档 确保 .rst 和 XML 数据都是最新的。\n","date":"2025-05-29T10:10:02+08:00","permalink":"https://xenithya.github.io/p/sphinx-doxygen/","title":"Sphinx Doxygen"},{"content":"git 常用命令 初始化 初始化一个仓库并提交\n1 2 3 4 5 6 git init git remote add origin https://gitlink.com/yourusername/repo.git git pull --rebase origin master git push -u origin master # 或 git push -u origin main git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your@email.com\u0026#34; 合并不相关内容的提交 1 git pull --rebase submodule 下载 下载带有 submodule 的仓库\n1 2 3 git clone --recursive \u0026lt;主仓库地址\u0026gt; # 或 git clone --recurse-submodules \u0026lt;主仓库地址\u0026gt; 添加 添加一个子模块到仓库：\n1 2 3 git submodule add https://github.com/user/lib-example.git libs/external git add .gitmodules libs/external # 添加子模块元数据及目录 git commit -m \u0026#34;feat: 添加子模块 lib-example\u0026#34; 添加子模块并指定分支\n1 2 3 4 5 git submodule add -b dev https://example.com/repo-b.git path/to/submodule git add .gitmodules path/to/submodule git commit -m \u0026#34;Add submodule repo-b using \u0026#39;dev\u0026#39; branch\u0026#34; git push 删除 彻底从 Git 仓库中移除一个子模块（submodule）\n1 2 3 4 5 6 7 git submodule deinit -f 子模块路径 # 示例：git submodule deinit -f libs/logger git rm --cached 子模块路径 # 示例：git rm --cached libs/logger rm -rf 子模块路径 # 示例：rm -rf libs/logger rm -rf .git/modules/子模块路径 # 示例：rm -rf .git/modules/libs/logger git add .gitmodules # 提交配置变更 git commit -m \u0026#34;移除子模块：子模块路径\u0026#34; # 示例：git commit -m \u0026#34;移除子模块：libs/logger\u0026#34; git push origin 主分支名 # 示例：git push origin main 验证是否删除干净​\n1 2 cat .git/config | grep submodule ls -la .git/modules 更新 在主仓库中更新子模块引用\n1 git submodule update --remote ​​提交主仓库的变更\n1 2 3 git add .gitmodules path/to/submodule git commit -m \u0026#34;更新子模块引用至最新提交\u0026#34; git push origin main 克隆主仓库时拉取最新子模块\n1 git clone --recurse-submodules https://github.com/your/main-repo.git 或者克隆后执行：\n1 git submodule update --init --recursive 参数 \u0026ndash;recurse-submodules 会同步子模块的最新提交（基于主仓库记录的ID） 验证子模块状态\n1 git submodule status 子模块内容更新后同步到主仓库\n1 2 3 4 5 6 cd submodule_name git pull origin dev # 拉取最新代码 cd .. git add submodule_name git commit -m \u0026#34;Update submodule to latest dev\u0026#34; git push 查看有哪些子模块 1 git config --file .gitmodules --get-regexp path 分支 切换到已存在的分支 若你要切换到本地已有的分支，可使用 git switch 命令（Git 2.23 版本及以后适用），或者传统的 git checkout 命令。\n1 2 3 4 5 # 方法一：使用switch命令（推荐） git switch \u0026lt;分支名\u0026gt; # 方法二：使用checkout命令（传统方式） git checkout \u0026lt;分支名\u0026gt; 创建并切换到新分支 当你需要创建一个新分支并立即切换过去时，可采用以下方式：\n1 2 3 4 5 # 方法一：使用switch命令（推荐） git switch -c \u0026lt;新分支名\u0026gt; # 方法二：使用checkout命令（传统方式） git checkout -b \u0026lt;新分支名\u0026gt; 切换到远程分支（跟踪远程分支） 要是你想切换到远程仓库的某个分支，需先创建一个跟踪该远程分支的本地分支：\n1 2 3 4 5 6 7 8 # 方法一：自动创建并跟踪远程分支 git switch -c \u0026lt;本地分支名\u0026gt; origin/\u0026lt;远程分支名\u0026gt; # 简化版：如果本地分支名和远程分支名一样 git switch -t origin/\u0026lt;远程分支名\u0026gt; # 方法二：使用checkout命令 git checkout -b \u0026lt;本地分支名\u0026gt; origin/\u0026lt;远程分支名\u0026gt; 查看本地分支 1 git branch 查看本地 + 远程分支 1 git branch -a # 或 --all 查看远程分支（仅远程） 1 git branch -r # 或 --remotes 总结表格\n命令 作用 git branch 查看本地分支 git branch -a 查看本地+远程分支 git branch -r 查看远程分支 git branch -v 查看分支+最后一次提交信息 git branch --merged 查看已合并到当前分支的分支 git branch --no-merged 查看未合并到当前分支的分支 git branch -vv 检查所有本地分支是否追踪远程 本地分支与远程分支对齐 1 2 3 4 git checkout -b dev origin/dev git checkout -b arm_linux origin/arm_linux git checkout -b dsp_bare origin/dsp_bare git checkout -b dsp_rtt origin/dsp_rtt 回退版本 强制回退\n1 2 3 4 5 6 7 8 # 查看历史 git log --oneline # 回退到某版本 git reset --hard \u0026lt;commit_id\u0026gt; # 强制推送（危险操作） git push origin HEAD --force 软回退（不破坏历史），也可以用 revert\n1 git revert \u0026lt;commit_id\u0026gt; # 撤销一个特定提交，但保留提交历史 创建版本 tag 主仓库和子模块都打 tag，并且主仓库在这个 tag 上锁定子模块的 tag 对应的 commit。\n1️⃣ 创建版本 tag（主仓库 + 子模块一起） 假设你现在主仓库是 app_linux_arm，有子模块 pnna_driver 和 examples。\n步骤\n进入每个子模块，打 tag：\n1 2 3 4 5 6 7 8 9 10 11 cd pnna_driver git checkout main # 或你开发的分支 git pull origin main git tag v20250829-driver git push origin v20250829-driver cd ../examples git checkout main git pull origin main git tag v20250829-examples git push origin v20250829-examples 回到主仓库，确保子模块都指向刚才的 tag：\n1 2 3 cd .. git add pnna_driver examples git commit -m \u0026#34;Lock submodules to v20250829-driver and v20250829-examples\u0026#34; 给主仓库打 tag：\n1 2 git tag v20250829 git push origin v20250829 这样就保证：\napp_linux_arm@v20250829 固定指向某个 commit； 这个 commit 里，pnna_driver 和 examples 也固定到对应 tag 的 commit。 → 完全可复现 ✅。 2️⃣ 下载（clone 带子模块和 tag 的版本） 用户（或者你自己换电脑）需要获取这个固定版本，只需：\n1 git clone --branch v20250829 --recurse-submodules https://gitlink.org.cn/nudt_dsp/app_linux_arm.git 然后子模块会被自动 checkout 到主仓库记录的 commit（也就是你当时打 tag 时的 commit）。\n3️⃣ （可选验证）子模块确实在 tag 上 进入子模块验证：\n1 2 3 4 5 6 7 cd pnna_driver git describe --tags # 应该输出 v20250829-driver cd ../examples git describe --tags # 应该输出 v20250829-examples 删除 tag 1 2 3 4 5 # 删除本地 git tag -d v20250829 # 删除远程 git push origin :refs/tags/v20250829 看主仓库当前指向的子模块提交 1 git submodule status 输出形如：\n1 2 be7fa48 examples (v20250829-examples) 1a2b3c4 pnna_driver (v20250829-driver) ✅ 总结：\n子模块打 tag → 有独立版本号，方便复用； 主仓库打 tag 并提交子模块指针 → 锁定依赖关系； clone 时带 --recurse-submodules → 能完整复现当时环境。 其他 删除远程仓库中的文件夹 ​​若 .vscode 已存在于 .gitignore 但未被忽略​​ 可能是缓存未更新，需先清除缓存：\n1 2 3 4 git rm -r --cached .vscode/ git add . git commit -m \u0026#34;修复 .gitignore 缓存问题\u0026#34; git push 通过以上步骤，即可精准删除远程仓库的 .vscode 文件夹，同时保留本地配置\n让 Git 不再跟踪 Makefile 1 2 3 4 5 6 7 8 9 10 11 12 13 # 验证 Makefile 是否被追踪 git ls-files | grep Makefile # 1. 移除已有文件的 Git 跟踪 git rm --cached Makefile # 2. 确保 .gitignore 中有写： echo \u0026#34;Makefile\u0026#34; \u0026gt;\u0026gt; .gitignore # 3. 提交更新 git add .gitignore git commit -m \u0026#34;Ignore Makefile\u0026#34; git push 让本地修改 Makefile，但不被提交: 使用 Git 的 assume-unchanged 标志（适合不希望本地改动被 Git 检测到）\n1 git update-index --assume-unchanged Makefile 此命令的作用是： 告诉 Git：“我本地会改这个文件，但你别提醒我，也别把改动加入 commit。”\n💡 检查状态：\n1 git ls-files -v | grep Makefile 前面有小写 h 表示被标记为“assume unchanged”。\n🔁 若以后你又需要提交 Makefile 的改动，可以恢复跟踪：\n1 git update-index --no-assume-unchanged Makefile 如果你只是不希望本地对 Makefile 的更改被提交，但远程还保留原始文件，你应该执行：\n1 git update-index --assume-unchanged Makefile 而不是用 git rm \u0026ndash;cached，否则会导致远程删除。\nhugo 生成一个新的 markdown 文件\n1 hugo new post/rtconfig_explanation/index.md 然后在 index.md 中，修改 draft 参数\n1 draft = false ","date":"2025-04-25T16:26:50+08:00","permalink":"https://xenithya.github.io/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Git常用命令"},{"content":"Microsoft Remote Desktop（RDP ）优化流程 引用文章：RDP 优化流程\n默认使用的时候会感觉很卡顿，网速明明很好，但是就是很卡顿。其中核心的几个点设置好了，基本上就解决大部分问题了。\n一、远程会话环境设置 Win+R打开运行，输入\n1 gpedit.msc 找到:\n计算机配置-\u0026gt;管理模板-\u0026gt;Windows组件-\u0026gt;远程桌面服务-\u0026gt;远程桌面会话主机-\u0026gt;远程会话环境。\n下面这几个打开，有效提高rdp性能。\n二、连接设置 找到:\n计算机配置-\u0026gt;管理模板-\u0026gt;Windows组件-\u0026gt;远程桌面服务-\u0026gt;远程桌面会话主机-\u0026gt;连接。\nrdp协议同时使用udp和tcp。有效增加网络稳定性和传输速率。\n三、注册表设置\n打开注册表编辑器\n把这个复制粘贴过去：\n1 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations 敲回车\n在空白处右键-\u0026gt;新建-\u0026gt;DWORD（32位）值，命名为\n1 DWMFRAMEINTERVAL 双击刚添加的这一项，基数选择为十进制，数值数据填写8.\n写8的话，就是120fps+，会占用显卡使用率，15的限制的是60fps。我建议直接写8就行了。当然你要是显卡可以，数字越小越好。\n测试fps网站： fps测试网站\n更流程参考：sunshine(服务端)+moonlight(客户端)\n","date":"2025-04-25T16:10:47+08:00","permalink":"https://xenithya.github.io/p/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/","title":"远程桌面设置"},{"content":"Linux 常用命令 查看进程所在的核ID号 1 2 3 4 pidof a.out # 获取pid ps -o pid,psr,comm -p \u0026lt;pid\u0026gt; taskset -c -p \u0026lt;pid\u0026gt; top -p \u0026lt;pid\u0026gt; # 按f进入菜单，空格键选择P，ESC退出，在最后一栏显示cpuid 显示终端输入过的命令 1 2 history # 每个命令都有一个命令号id，输入：!id 即输入该id对应的命令 进程绑定cpu 1 2 3 numactl --hardware #查看cpu numactl --show numastat shell获取当前目录 1 2 CURRENT_DIR=$(cd $(dirname $0);pwd) echo ${CURRENT_DIR} 获取程序运行时间 第一种方法 1 2 3 4 5 6 7 8 9 #include \u0026lt;sys/time.h\u0026gt; struct timeval startTime, endTime; float timeUsed; gettimeofday(\u0026amp;startTime, NULL); ... gettimeofday(\u0026amp;endTime, NULL); timeUsed = 1000000 * (endTime.tv_sec - startTime.tv_sec) + (endTime.tv_usec - startTime.tv_usec); timeUsed /= 1000000; printf(\u0026#34;total times:[%f]s\\n\u0026#34;, timeUsed); 第二种方法 1 2 3 4 5 #include \u0026lt;time.h\u0026gt; clock_t start = clock(); // the code need to measure time clock_t end = clock(); double timeSpend = (double)(end - start) / CLOCKS_PER_SEC; //得到的结果是秒，(end-start)得到的结果是毫秒，不适用于多线程场合 第三种方法 1 2 3 4 #include \u0026lt;Windows.h\u0026gt; DWORD start = GetTickCount(); DWORD end = GetTickCount(); DWORD timeSpend = end - start; //得到的结果是毫秒 第四种方法 1 2 3 4 5 6 7 8 9 #include \u0026lt;Windows.h\u0026gt; LARGE_INTEGER t1,t2,tc; QueryPerformanceFrequency(\u0026amp;tc); QueryPerformanceCounter(\u0026amp;t1); ... QueryPerformanceCounter(\u0026amp;t2); double time=(double)(t2.QuadPart-t1.QuadPart)/(double)tc.QuadPart; printf(\u0026#34;total times:[%lf] ms\\n\u0026#34;, time * 1000);//ms (double)tc.QuadPart: 10 000 000 mpich命令 1 2 3 4 5 #mpiexec -l -hosts cn0,cn1 -wdir ./armcore0/host_code/ ./vec_add_host 1024 24 :\\ mpiexec -l -f ./machinefile -wdir ./armcore0/host_code/ ./vec_add_host 1024 24 :\\ -wdir ./armcore4/host_code/ ./vec_add_host 24 :\\ -wdir ./armcore8/host_code/ ./vec_add_host 1024 24 :\\ -wdir ./armcore12/host_code/ ./vec_add_host 1024 24 其中machinefile内容为：\n1 2 cn0:1 cn1:1 表示cn0执行这4个程序一遍，如果machinefile中的内容为cn0:4则表示执行这4个程序4遍。\nmachinefile也可以用\n1 -hosts cn0,cn1 -n 8 代替。\n免密登录 免密登录本地：\n1 ssh localhost 执行命令：\n1 ssh-keygen -t rsa 生成之后会在用户的根目录生成一个 “.ssh”的文件夹，文件夹下有这几个文件\nid_rsa : 生成的私钥文件 id_rsa.pub ： 生成的公钥文件\nknow_hosts : 已知的主机公钥清单\n本地生成的公钥添加到目标服务器的 authorized_keys 文件中\n1 2 #ssh-copy-id 将key写到远程机器的～/.ssh/authorized_keys文件中 ssh-copy-id -i .ssh/id_rsa.pub xyy@172.168.0.11 登录远程机器\n1 ssh root@172.168.0.11 创建新用户及用户权限 增加用户： (1)在root权限下\n命令：useradd +用户名，它不会在/home目录下创建同名文件夹，也没有创建密码，因此利用这个用户登录系统，是登录不了的；\n命令：useradd -m +用户名，将在/home目录下创建同名文件夹，然后利用（ passwd + 用户名）为指定的用户名设置密码。\nuseradd选项:\n1 2 3 4 5 6 -c # comment 指定一段注释性描述。 -d # 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g # 用户组 指定用户所属的用户组。 -G # 用户组，用户组 指定用户所属的附加组。 -s # Shell文件 指定用户的登录Shell。 -u # 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 (2)命令：adduser +用户名，在/home目录下会自动创建同名文件夹\n创建新用户后，同时会在etc目录下的passwd文件中添加这个新用户的相关信息\n创建新用户后shell无法自动补全命令或使用基本的shell命令\n按照上述命令创建一个新用户后，提示符仅仅是一个$，输入命令，用TAB键也无法补全命令。并且没有命令历史功能。\n使用root用户查看passwd文件\n1 grep 用户名 /etc/passwd 可以发现默认的shell 是/bin/sh，将其修改为/bin/bash 后即可\n1 vi /etc/passwd 删除用户： 1 2 3 userdel username #若想将它在系统上的文件也删除掉，使用命令： userdel -r username 修改用户参数： 1 usermod --help # 查看修改用户这个命令的相关参数 用户的相互切换： 1 su 用户名 # su是switch user的缩写，表示用户切换 用户组的添加和删除： 1 2 groupadd testgroup # 组的添加 groupdel testgroup # 组的删除 说明：组的增加和删除信息会在etc目录的group文件中体现出来。\n示例：\n1 2 3 4 5 useradd -m xyy passwd xyy chown -R xyy ./xyy chgrp -R xyy ./xyy/ vim /etc/passwd # 将其修改为/bin/bash 后即可 vim删除多行 1 9,12d linux新建用户组权限 比如找不到root下安装好的mpi\n方法：修改在xyy用户下的.bashrc文件，将路径添加到末尾，再source .bashrc即可。\n编译内核 1 make mrproper # 清空一些配置信息检查源码是否完整 在当前目录下执行：\n1 2 3 4 5 6 make # 相当于make bzImage加make modules） ## 另外make可以加-j 20 意思启动20个线程编译 make modules #生成相应的模块 make modules_install #将相应的模块拷贝到对应的目录下 make install #该命令的作用是将.config，vmlinuz，initrd.img，System.map文件到/boot/目录、更新grub。默认启动新内核 配置内核 在正式编译内核之前，我们首先必须配置需要包含哪些模块。实际上，有一些非常简单的方式来配置。使用一个命令，你能拷贝当前内核的配置文件，然后使用可靠的 menuconfig 命令来做任何必要的更改。\n1 cp /boot/config-$(uname -r) .config 上述命令的意思就是拷贝对应当前内核配置到当前目录下并重命名为.config(文件名前加.意思为隐藏文件)。\n可以自行查看下：\n1 uname -r 的输出\n之后执行命令：\n1 make menuconfig 生成的配置文件在\n1 /home/sys/linux-4.19.46-mt/.config 编译和安装 退出menuconfig后，在命令行中输入\n1 make -j4 命令即可开始编译。-j4意思是并发执行，可以提高速度，一般情况 下不要多于CPU核数。这个命令的执行会耗费很长时间。\n编译完成之后首先安装模块，命令为：\n1 sudo make modules_install 安装内核， 命令为： 1 sudo make install 回到顶部 启用内核作为引导，输入下列命令将内核作为引导，将数字更改为你自己编译的版本号：\n1 sudo update-initramfs -c -k 5.3.10 下面更新一下grub：\n1 sudo update-grub 之后重启即可在启动界面选择需要启动的内核。如果看不到启动选择界面，请执行以下操作：\n1 sudo vi /etc/default/grub 将文件修改为以下模式：（注释掉hidden那一行，将timeout更改为较大值，这里改为了10）之后执行\n1 sudo update-grub 自定义grub启动项 修改启动项名称:\n在ubuntu下，可以直接修改/boot/grub/grub.cfg中有关启动项的名称。\n增加自定义启动项 复制/boot/grub/grub.cfg有关启动项的内容到/etc/grub.d/40_custom进行自定义即可。\n执行update 最后都要执行下述命令以生效。\n1 sudo update-grub 按时间列举目录下文件 1 ll -rt DD复制硬盘 1 2 3 4 5 6 7 8 #查看硬盘盘符： fdisk -l|grep /dev/sd #格式化硬盘： mkfs.ext4 /dev/sdn # n=要格式的盘id #拷贝硬盘： dd if=/dev/sdj of=/dev/sdk bs=64M shell脚本获取当前路径 方法一 1 2 3 #!/usr/bin/env bash Cur_Dir=$(pwd) echo $Cur_Dir 方法二 1 2 3 4 5 6 #!/usr/bin/env bash basedir=cd $(dirname $0); pwd -P echo $basedir # dirname $0，取得当前执行的脚本文件的父目录 # cd dirname $0，进入这个目录(切换当前工作目录) # pwd，显示当前工作目录(cd执行后的) 查看文件夹大小 1 2 du -h –max-depth=1 /var/log/* du -sh /* 查看文件夹下有多少个文件 查看目录下有多少个文件及文件夹需在终端输入 1 ls | wc -w 查看目录下有多少个文件需在终端输入 1 ls | wc -c 查看文件夹下有多少个文件，多少个子目录需在终端输入 1 ls -l |wc -l 若只想知道文件的个数，则需在终端输入 1 /bin/ls -l |grep ^-|wc -l 环境变量 1 2 /etc/profile.d # 用户每次登录，会执行该文件夹下的所有.sh文件 网络bind error 1 2 # Address already in use netstat -tanlp 查看内核版本 1 2 cat /etc/issue cat /proc/version 查看cpu个数及核心数 总核数 = 物理CPU个数 X 每颗物理CPU的核数 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数\n查看物理CPU个数 1 cat /proc/cpuinfo| grep \u0026#34;physical id\u0026#34;| sort| uniq| wc -l 查看每个物理CPU中core的个数(即核数) 1 cat /proc/cpuinfo| grep \u0026#34;cpu cores\u0026#34;| uniq 查看逻辑CPU的个数 1 cat /proc/cpuinfo| grep \u0026#34;processor\u0026#34;| wc -l 查看线程数 1 grep \u0026#39;processor\u0026#39; /proc/cpuinfo | sort -u | wc -l 注意，此处查看的线程数是总的线程数，可以理解为逻辑cpu的数量\n设置堆栈大小 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;sys/resource.h\u0026gt; struct rlimit rlim, rlim_new; if (getrlimit(RLIMIT_STACK, \u0026amp;rlim) == 0) { printf(\u0026#34;****** [%d]: %ld %ld ******\\n\u0026#34;, __LINE__, rlim.rlim_cur, rlim.rlim_max); // rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY; rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_cur; if (setrlimit(RLIMIT_STACK, \u0026amp;rlim_new)!=0) { rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max; setrlimit(RLIMIT_STACK, \u0026amp;rlim_new); } } getrlimit(RLIMIT_STACK, \u0026amp;rlim); printf(\u0026#34;****** [%d]: %ld %ld ******\\n\u0026#34;, __LINE__, rlim.rlim_cur, rlim.rlim_max); mkstemp 1 2 #include \u0026lt;stdlib.h\u0026gt; int mkstemp(char * template); 函数说明：\nmkstemp()用来建立唯一的临时文件. 参数template 所指的文件名称字符串中最后六个字符必须是XXXXXX.\nmkstemp()会以可读写模式和0600 权限来打开该文件, 如果该文件不存在则会建立该文件. 打开该文件后其文件描述词会返回.\n文件顺利打开后返回可读写的文件描述词. 若果文件打开失败则返回NULL, 并把错误代码存在errno 中.\n错误代码：EINVAL 参数template 字符串最后六个字符非XXXXXX. EEXIST 无法建立临时文件.\n查看内核版本号 1 uname -r lspci -k 选项表示输出信息中显示正在使用的驱动和内核中可以支持该设备的模块。\n1 lspci -k -s 08:00.0 系统时间设置 1 2 3 date 1118184321 # 11 18 18 43 21 # 月 日 时 分 年 查找指定字符串 1 grep -rn reserve_all_mem_mt_safe 开机自动加载模块 1 depmod 将需要加载的.ko文件放到\n1 /lib/modules/$(uname -r)/update 新建的文件夹下\n然后执行depmod即可，在\n1 /lib/modules/$(uname -r)/modules.dep 文件中能看到需要加载的.ko文件 或在\n1 /etc/rc.local 文件中添加\n编译成模块 1 make -C /home/sys/linux-4.19.46-mt/ M=`pwd` modules 卸载PCI设备 1 echo 1 \u0026gt; /sys/bus/pci/device/0000\\:03\\:00.0/remove 重新对PCI/PCIe总线进行枚举，可执行命令\n1 2 3 4 5 echo 1 \u0026gt; /sys/bus/pci/rescan $make modules $sudo make modules_install $sudo make install update-initramfs: Generating /boot/initrd.img-4.19.46-vfio-1119+ vscode添加头部注释 搜索 fileheader\n安装 koroFileHeader\n修改 设置-\u0026gt;fileheader-\u0026gt;config obj-\u0026gt;setting.json\n1 2 ctrl + alt + i # 生成头部注释 ctrl + alt + t # 生成函数注释 Linux C内存泄漏检查 1 valgrind --tool=memcheck --leak-check=full ./test Linux程序前台后台切换 在Linux终端运行命令的时候，在命令末尾加上 \u0026amp; 符号，就可以让程序在后台运行 1 root@Ubuntu$ ./tcpserv01 \u0026amp; 如果程序正在前台运行，可以使用 Ctrl+z 选项把程序暂停，然后用 bg %[number] 命令把这个程序放到后台运行，摁Ctrl+z，然后在最后一行加上 1 bg %number 对于所有运行的程序，我们可以用jobs –l 指令查看 1 [kettle@4 data-integration]$ jobs -l 也可以用 fg %[number] 指令把一个程序掉到前台 1 2 cat@Ubuntu:~/unp/unpv13e/tcpcliserv$ fg %1 ./tcpserv01 也可以直接终止后台运行的程序，使用 kill 命令 1 cat@Ubuntu:~/unp/unpv13e/tcpcliserv$ kill %1 任意类型循环左右移位n位 1 2 3 #define LOGIC_LSHIFT_NBIT_TYPE(data, nbit, type) ((type)((data \u0026gt;\u0026gt; (sizeof(type) \u0026lt;\u0026lt; 3) - nbit) | (data \u0026lt;\u0026lt; nbit))) #define LOGIC_RSHIFT_NBIT_TYPE(data, nbit, type) ((type)((data \u0026lt;\u0026lt; (sizeof(type) \u0026lt;\u0026lt; 3) - nbit) | (data \u0026gt;\u0026gt; nbit))) #define LOGIC_RSHIFT_NVLAN(data, nbit) ((data | (1 \u0026lt;\u0026lt; (nbit))) | 0xFFFFFFF) lspci -vv Linux 中用于显示 PCI/PCIe 设备超详细硬件信息的命令\n__builtin_popcount GCC 编译器中四个重要的内置函数之一。__builtin_popcount(x)：该函数用于计算一个整数的个数(设置位)。\n绑定CPU的C代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #define _GNU_SOURCE #include \u0026lt;sched.h\u0026gt; void set_CPU_affinity(int core_id) { cpu_set_t mask; CPU_ZERO(\u0026amp;mask); CPU_SET(core_id, \u0026amp;mask); sched_setaffinity(0, sizeof(cpu_set_t), \u0026amp;mask); } void get_CPU_affinity() { cpu_set_t get; CPU_ZERO(\u0026amp;get); if (sched_getaffinity(0, sizeof(get), \u0026amp;get) == -1)//获取线程CPU亲和力 { printf(\u0026#34;warning: cound not get thread affinity, continuing...\\n\u0026#34;); } int i; for (i = 0; i \u0026lt; 16; i++) { if (CPU_ISSET(i, \u0026amp;get))//判断线程与哪个CPU有亲和力 { printf(\u0026#34;this thread %d is running processor : %d\\n\u0026#34;, i,i); } } } cgroup执行命令 使用 Linux ​cgroups（控制组）​来限制进程 CPU 资源\n1 cgexec -g cpu:test_cpu ./a.out /bin/bash有字符\u0026rsquo;\\r\u0026rsquo;无法解析 1 2 3 vi hello.sh ### Esc进入命令行运行模式 ### : set ff=unix ","date":"2025-04-25T16:10:29+08:00","permalink":"https://xenithya.github.io/p/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Linux 常用命令"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://xenithya.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://xenithya.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://xenithya.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://xenithya.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"VSCode \u0026amp;\u0026amp; Git 你在 VSCode 中每次提交/推送代码都要输入用户名和密码，这通常说明你的 Git 没有配置凭据缓存或没有使用 SSH key。\n✅ 最推荐的解决方式：配置 SSH 密钥登录 Git 仓库 这样你推送时不再需要输入用户名和密码。\n🧩 步骤一：检查你使用的是 HTTPS 还是 SSH 打开 VSCode 的终端（或命令行）：\n1 git remote -v 输出类似这样说明你是用 HTTPS（每次都需要账号密码）：\n1 2 origin https://gitlink.org.cn/yourname/yourrepo.git (fetch) origin https://gitlink.org.cn/yourname/yourrepo.git (push) 建议：换成 SSH\n🛠️ 步骤二：生成 SSH 密钥（如果你还没有） 在终端执行：\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 按提示选择路径（默认 ~/.ssh/id_rsa）并设置密码（或留空）。\n生成后，执行：\n1 cat ~/.ssh/id_rsa.pub 复制这段 公钥内容。\n🔗 步骤三：将 SSH 公钥添加到远程仓库平台（如 GitLink、GitHub、Gitee） 以 GitLink 为例：\n登录 https://gitlink.org.cn 点击右上角头像 → 设置 → SSH公钥 添加你复制的 id_rsa.pub 内容 🔄 步骤四：修改 Git 远程地址为 SSH 格式 1 git remote set-url origin git@gitlink.org.cn:nudt_dsp/yourrepo.git 再次检查确认：\n1 git remote -v 输出应变为：\n1 2 origin git@gitlink.org.cn:nudt_dsp/yourrepo.git (fetch) origin git@gitlink.org.cn:nudt_dsp/yourrepo.git (push) 🧪 步骤五：测试是否成功 执行：\n1 git push 如果你首次用 SSH 会提示确认 gitlink.org.cn 的 host key，输入 yes 即可。之后就不会再提示用户名和密码了。\n💡 补充（可选方式）：启用 Git 凭据缓存（仅适用于 HTTPS） 1 git config --global credential.helper store 然后执行一次：\n1 git push 输入一次用户名和密码后，Git 会将其明文保存在本地磁盘（风险较高，不推荐用于公司电脑或公共机）。\n✅ 推荐方案总结 方法 是否推荐 安全性 说明 使用 SSH key（推荐） ✅ 强烈推荐 高 一次设置终身免输 使用 HTTPS + 凭据缓存 ⚠️ 一般 较低 明文保存，风险较大 每次输入用户名密码 ❌ 不推荐 高 太麻烦 如果你是在公司网络、用的是 Windows、Mac 或 Linux，我可以提供更具体的脚本或配置。需要的话告诉我系统平台即可。\n","date":"2019-03-09T00:00:00Z","image":"https://xenithya.github.io/p/vscode-git/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://xenithya.github.io/p/vscode-git/","title":"VSCode \u0026\u0026 Git"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://xenithya.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://xenithya.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://xenithya.github.io/p/emoji-support/","title":"Emoji Support"}]